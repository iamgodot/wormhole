# URL Shortener Design

一般来说，短链服务应当满足两个核心功能：URL 转换和访问跳转，因此需要实现 Short link 的生成，并保存原 URL 与其的映射关系。

对于 Short link 的格式，Base62 包含了 `[0-9a-zA-Z]` 共 62 个字符，使用六位字符所有的排列组合大约有 56.8 Billion 种结果，这里选择六位作为生成结果。如果不够，还可以增加更多位数，而且也可以选择 Base64 或者从 Base62 中去除 `0OIl1` 等容易混淆的字符。

下面针对 Short link 的生成，主要记录哈希和 KGS 两种方案。

## 哈希方案

### 1. 功能实现

哈希算法可以用来保证转换的单向性和绝大多数情况下的唯一性，也就是说对于不同的 URL 会直接转换为不重复的 Short link，而相同的 URL 总会得到同样的结果（不考虑根据用户区分等 Features）。另外，还要考虑通过增加随机部分来避免碰撞。Wormhole 的具体做法如下：

- 对于合法的 URL，先计算 MD5 的结果（如果有登录，则将 UID 与 URL 拼接）
- 根据上面的结果进行 Base62 编码转换，得到 22 位字符
- 从中选取前 6 位作为 URL 的 Alias
- 如果数据表中没有相同 Alias 的记录，插入新记录并返回结果
- 如果存在相同 Alias 的记录，分两种情况
  - URL 相同，直接返回结果
  - URL 不同，重新拼接 URL + (UID) + Timestamp 并从头计算（说明遇到了哈希碰撞，这种情况应当极其罕见）

### 2. 数据存储

数据表分成两张，一张保存 User 数据，另外一张记录 Short links:

- Table User

- Table ShortLink

  - URL

  - Alias: 生成的六位 base62 字符
  - Randoms: 默认为空，如果碰撞则记录使用的 Timestamp 的字符串
  - UID

### 3. 优缺点

- 好处是实现思路简单直接，哈希保证了大部分情况下的唯一性生成
- 缺点是需要单独考虑碰撞的情况

## KGS 方案

哈希方案需要在每次请求到达之后再进行计算，在高并发（生成）的场景下性能瓶颈会集中在数据库的读写上，如果可以提前生成要用的 Short links 会进一步提高 Shortener 的处理能力，而且也避免了哈希碰撞。

### 1. 功能实现

KGS 作为单独的号码分发服务，会提前生成好许多备用的 Alias，生成方式有很多，比如直接利用 MySQL 的自增 ID，为了不过于 predictable 也可以结合 Timestamp 混合生成。之后 Shortener 会直接通过 KGS 获取新的 Alias，这个过程就不需要等待额外的计算处理。为了避免每次的数据库查询，还可以把一部分 Aliases 放到内存或者 Redis 中，以此来加速分发。注意如果 KGS 宕机会导致内存中的 Aliases 未使用而被浪费掉，针对这种情况可以在重启后做恢复性检查。

具体的 KGS 工作流程如下：

- 定时检查数据表中的可用 Aliases，如果过少则触发生成
- 定时检查 Redis 中的可用 Aliases，如果过少则添加，添加过程中标记相应的 RDS 记录为已使用
- 如果宕机，重启后通过对比 ShortLink 表和 Aliases 表进行数据恢复
- 从 Redis 中返回新的 Alias 给 Shortener

为了保证同一个 URL 不浪费多个号码，需要根据 URL 检查是否已经存在对应的记录。因为 URL 可能会比较长，也可以再存储其摘要结果做对比。具体的 Shortening 流程如下：

- 对新的 URL 做 MD5 计算
- 根据计算结果和 UID 在表中查找，如果有结果则直接返回
- 如果没有，那么向 KGS 请求新的 Alias 然后插入新记录，之后返回结果

### 2. 数据存储

除了 User 表和 ShortLink 表，还需要一张 Alias 表保存备用的号码：

- Table User

- Table ShortLink
  - URL
  - Hash: URL 摘要
  - Alias: 六位 base62 字符
  - UID
- Table Alias
  - Alias
  - Used: 标记是否已经分配

### 3. 优缺点

- 好处是相比哈希方案可以进一步提高性能，尤其是针对短时间内的大量请求，同时也不需要考虑哈希碰撞的情况
- 缺点是需要额外的 KGS 和 Alias 表，另外要解决好可能出现的同步问题，即把同一个号码分发给多个请求

## 性能

除了高并发的场景，还要保证服务的可用性，比如 KGS，以及安全性，像 Alias 不应当使用太容易被破解的计算方案。

常用的架构模式包括缓存、集群部署、负载均衡和数据库读写分离都可以适当地考虑使用。下面对使用量方面进行简单地估算：

- 假设用户对 URL Shortener 的使用读多写少，并且访问量和转换量的比例是 100:1
- 流量估算
  - 假设每天的转换量是 100 万，那么访问量就是 1 亿
  - 那么每天的转换吞吐量为 `10^6 / 24 / 3600 = 12 URL/s`，访问吞吐量为 `1200 URL/s`
  - 如果每天的使用集中在白天八小时的话，吞吐量是原来的三倍
- 存储估算
  - 假设一个 URL 需要 200 Bytes 的空间记录，按上述访问量持续一年
  - 总数据量约为 `365 * 10^6 * 200 = 7.3 * 10^10 Bytes = 73 GB`
- 带宽估算
  - 写：`12 * 200 = 2400 Bytes/s = 2.4 KB/s`
  - 读：`240 KB/s`
- 缓存估算
  - 按照二八原则来计算，一天的缓存量为访问量的 20%，假设缓存有效期为一天
  - 那么缓存大约占用 `10^8 * 200 * 20% = 4 GB`

## 附加功能

对于转换和访问两大核心功能都有可以扩展的方向：

- URL 转换
  - 对不同的用户，同一个 URL 生成的 Short link 也不一样
  - Short links 有默认的过期时间，同时支持用户自定义（有上限）
  - 对每个用户，转换有一定的配额限制
  - 支持定制 Short link
- 访问
  - 跳转结果的统计
  - 对于 404 等问题 URL 返回自定义页面

## 其他问题

- 对于 Encoded URL 是否要单独处理

- 对于只是 Appended slash 不同的 URL 是否要合并